# --- Part Two ---
# For some reason, your simulated results don't match what the experimental
# energy source engineers expected. Apparently, the pocket dimension actually
# has four spatial dimensions, not three.
#
# The pocket dimension contains an infinite 4-dimensional grid. At every
# integer 4-dimensional coordinate (x,y,z,w), there exists a single cube
# (really, a hypercube) which is still either active or inactive.
#
# Each cube only ever considers its neighbors: any of the 80 other cubes where
# any of their coordinates differ by at most 1. For example, given the cube at
# x=1,y=2,z=3,w=4, its neighbors include the cube at x=2,y=2,z=3,w=3, the cube
# at x=0,y=2,z=3,w=4, and so on.
#
# The initial state of the pocket dimension still consists of a small flat
# region of cubes. Furthermore, the same rules for cycle updating still apply:
# during each cycle, consider the number of active neighbors of each cube.
#
# For example, consider the same initial state as in the example above. Even
# though the pocket dimension is 4-dimensional, this initial state represents a
# small 2-dimensional slice of it. (In particular, this initial state defines a
# 3x3x1x1 region of the 4-dimensional space.)
 
# Simulating a few cycles from this initial state produces the following
# configurations, where the result of each cycle is shown layer-by-layer at
# each given z and w coordinate:
#
# Before any cycles:
#
# z=0, w=0
# .#.
# ..#
# ###
#
# After 1 cycle:
#
# z=-1, w=-1
# #..
# ..#
# .#.
#
# z=0, w=-1
# #..
# ..#
# .#.
#
# z=1, w=-1
# #..
# ..#
# .#.
#
# z=-1, w=0
# #..
# ..#
# .#.
#
# z=0, w=0
# #.#
# .##
# .#.
#
# z=1, w=0
# #..
# ..#
# .#.
#
# z=-1, w=1
# #..
# ..#
# .#.
#
# z=0, w=1
# #..
# ..#
# .#.
#
# z=1, w=1
# #..
# ..#
# .#.
#
# After 2 cycles:
#
# z=-2, w=-2
# .....
# .....
# ..#..
# .....
# .....
#
# z=-1, w=-2
# .....
# .....
# .....
# .....
# .....
#
# z=0, w=-2
# ###..
# ##.##
# #...#
# .#..#
# .###.
#
# z=1, w=-2
# .....
# .....
# .....
# .....
# .....
#
# z=2, w=-2
# .....
# .....
# ..#..
# .....
# .....
#
# z=-2, w=-1
# .....
# .....
# .....
# .....
# .....
#
# z=-1, w=-1
# .....
# .....
# .....
# .....
# .....
#
# z=0, w=-1
# .....
# .....
# .....
# .....
# .....
#
# z=1, w=-1
# .....
# .....
# .....
# .....
# .....
#
# z=2, w=-1
# .....
# .....
# .....
# .....
# .....
#
# z=-2, w=0
# ###..
# ##.##
# #...#
# .#..#
# .###.
#
# z=-1, w=0
# .....
# .....
# .....
# .....
# .....
#
# z=0, w=0
# .....
# .....
# .....
# .....
# .....
#
# z=1, w=0
# .....
# .....
# .....
# .....
# .....
#
# z=2, w=0
# ###..
# ##.##
# #...#
# .#..#
# .###.
#
# z=-2, w=1
# .....
# .....
# .....
# .....
# .....
#
# z=-1, w=1
# .....
# .....
# .....
# .....
# .....
#
# z=0, w=1
# .....
# .....
# .....
# .....
# .....
#
# z=1, w=1
# .....
# .....
# .....
# .....
# .....
#
# z=2, w=1
# .....
# .....
# .....
# .....
# .....
#
# z=-2, w=2
# .....
# .....
# ..#..
# .....
# .....
#
# z=-1, w=2
# .....
# .....
# .....
# .....
# .....
#
# z=0, w=2
# ###..
# ##.##
# #...#
# .#..#
# .###.
#
# z=1, w=2
# .....
# .....
# .....
# .....
# .....
#
# z=2, w=2
# .....
# .....
# ..#..
# .....
# .....
#
# After the full six-cycle boot process completes, 848 cubes are left in the
# active state.
#
# Starting with your given initial configuration, simulate six cycles in a
# 4-dimensional space. How many cubes are left in the active state after the
# sixth cycle?

library(dplyr)
library(purrr)
library(readr)

generations <- 6

# read board
input <- read_lines("input.txt")

# worst case, the board will grow by 1 in each dimension every cycle
width <- nchar(input[1]) + generations * 2
height <- length(input) + generations * 2
depth <- 1 + generations * 2
hyper <- 1 + generations * 2
z0 <- generations + 1
w0 <- generations + 1

# build board
board <- array(".", dim = c(height, width, depth, hyper))
board[generations + 1:nchar(input[1]), generations + 1:length(input), z0, w0] <- map(input, strsplit, "") %>%
  unlist() %>%
  matrix(length(input), byrow = T)

# build an array, the same size as the board, that has a list of all 26
# neighboring indicies
neighbors <- array(dim = c(height, width, depth, hyper, 80, 4))
for (y in 1:height) {
  for (x in 1:width) {
    for (z in 1:depth) {
      for (w in 1:hyper) {
        idxs <- expand.grid(
            y0 = max(y - 1, 1):min(y + 1, height),
            x0 = max(x - 1, 1):min(x + 1, width),
            z0 = max(z - 1, 1):min(z + 1, depth),
            w0 = max(w - 1, 1):min(w + 1, hyper)
          ) %>%
          filter(y0 != y | x0 != x | z0 != z | w0 != w)
        neighbors[y, x, z, w, 1:nrow(idxs), ] <- unlist(idxs)
      }
    }
  }
}

# run algo
for (generation in 1:generations) {
  print(generation)

  # cnt will be the same dimensions as board, but each element will be a count
  # of the number of active neighbors
  taken <- board == "#"
  cnt <- apply(neighbors, c(1, 2, 3, 4), function(idxs) sum(taken[idxs], na.rm = T))

  # compute the next generation
  board <- ifelse(
    taken,
    ifelse(cnt == 2 | cnt == 3, "#", "."),
    ifelse(cnt == 3, "#", ".")
  )
}

# sum of active cubes
sum(board == "#", na.rm = T)
